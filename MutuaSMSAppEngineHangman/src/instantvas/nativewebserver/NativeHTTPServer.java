package instantvas.nativewebserver;

import instantvas.smsengine.web.AddToMOQueue;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.InetSocketAddress;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.WeakHashMap;
import java.util.concurrent.Executors;

import com.sun.net.httpserver.*;

/** <pre>
 * NativeHTTPServer.java
 * =====================
 * (created by luiz, Dec 21, 2015)
 *
 * This class' purpose is to test the average speed of the native http server implementation.
 * 
 * For a process started like this on an interserver VPS 1 slot server (1GiB RAM, 1/4 of a CPU, 25GiB disk with 30MiB/s):
 * 	/tmp/jdk1.8.0_66/bin/java -Xms884M -Xmx884M -Xmn50M -Xss228k -XX:ReservedCodeCacheSize=6M -XX:+AlwaysPreTouch -XX:MaxMetaspaceSize=6M
 *                            -Xbatch -Xcomp -XX:+AggressiveOpts -Xshare:auto -Xverify:none -XX:-UseHugeTLBFS -XX:+RelaxAccessControlCheck
 *                            -XX:+UseAES -XX:+UseAESIntrinsics -XX:+UseCondCardMark -XX:-UseRTMLocking -XX:OnError="shutdown -r now"
 *                            -XX:OnOutOfMemoryError="shutdown -r now" -XX:+CMSParallelRemarkEnabled -XX:+UseCMSInitiatingOccupancyOnly
 *                            -XX:CMSInitiatingOccupancyFraction=95 -XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark -XX:+UseNUMA
 *                            -XX:+UseSerialGC -XX:-UseSHM -XX:+UseStringDeduplication -jar /tmp/InterserverMemoryManagement.jar 645 300000000
 * Note: it could run even faster on a WEB hosting machine, but this machines don't accept external connections
 * 
 * The following test achieve the following results on a jmeter session conducted on my laptop over a wi-fi connection:
 *  -- 20 server threads, 80 client threads (my wified lap -- min 317ms), 203,2/sec, ~.85 5min load --> 3 sec max for an answer
 *  -- 20 server threads, 100 client threads (idem), 245/sec, ~1.08 5min load --> 5,1 sec max for an answer
 *  -- same thing but without an SSH connection (java started in rc.local) --> 256/sec, ~0.83 5min load --> 4,2sec max for an answer
 *  -- 20 server threads, 120 client threads (min 281ms), 320/sec (with 360 peaks), ~0.81 5min load --> 4,6sec max for an answer
 *  -- with 150 client threads it appears I reached my BW limit (400/sec peaks and 250/sec valleys)
 *  
 *  The future of a embedded web server seems to be a home made implementation in 'MutuaGPP2PCommunications', specially
 *  designed for short textual SMS exchange with predictable answers, to avoid the big garbage generated by the available implementations.
 *
 * @see RelatedClass(es)
 * @version $Id$
 * @author luiz
 */

public class NativeHTTPServer {
	
	public static int NUMBER_OF_THREADS        = 20;
	public static int PARAMETERS_HASH_CAPACITY = 20;	// should be > total number of unique parameter names among all handlers
	public static int INPUT_BUFFER_SIZE   = 1024;
	public static long READ_TIMEOUT       = 100;

	public static void main(String[] args) throws IOException {
		startServer(80, 9999, InstantVASSMSWebHandlers.values());
		System.out.println("Started a :80 server. Please, request!");
	}
	
	public static void startServer(int port, int socketBacklogQueueSlots, INativeHTTPServerHandler[]... handlerArrays) throws IOException {
		HttpServer server = HttpServer.create(new InetSocketAddress(port), socketBacklogQueueSlots);
		for (INativeHTTPServerHandler[] handlers : handlerArrays) {
			for (INativeHTTPServerHandler handler : handlers) {
				server.createContext(handler.getContextPath(), handler);
			}
		}
		server.setExecutor(Executors.newFixedThreadPool(NUMBER_OF_THREADS));
		server.start();
	}
	
	private static WeakHashMap<Thread, HashMap<String, String>> parametersMaps = new WeakHashMap<Thread, HashMap<String, String>>(NUMBER_OF_THREADS);
	
	public static synchronized HashMap<String, String> getParametersHash() {
		HashMap<String, String> parameters = parametersMaps.get(Thread.currentThread());
		if (parameters == null) {
			parameters = new HashMap<String, String>(PARAMETERS_HASH_CAPACITY);
			parametersMaps.put(Thread.currentThread(), parameters);
		}
		return parameters;
	}
	
	public static HashMap<String, String> retrieveGetParameters(String queryString) throws UnsupportedEncodingException {
		
		HashMap<String, String> parameters = getParametersHash();
		parameters.clear();
		
		int nextTokenStart = 0;
		int nextTokenEnd   = -1;
		
		String parameterName  = "";
		String parameterValue = "";
		
		while (true) try {
			// gathering parameter name state
			nextTokenEnd = queryString.indexOf('=', nextTokenStart);
			if (nextTokenEnd == -1) {
				parameterName = queryString.substring(nextTokenStart).intern();
				break;
			}
			// note: for performance reasons, we: 1) do not 'URLDecoder' parameter names; 2) use .intern() for parameter names minimize the heap strings
			parameterName = queryString.substring(nextTokenStart, nextTokenEnd).intern();
			nextTokenStart = nextTokenEnd+1;		// skip the '=' character

			// gathering parameter value state
			nextTokenEnd = queryString.indexOf('&', nextTokenStart);
			if (nextTokenEnd == -1) {
				parameterValue = URLDecoder.decode(queryString.substring(nextTokenStart), "UTF-8");
				break;
			}
			parameterValue = URLDecoder.decode(queryString.substring(nextTokenStart, nextTokenEnd), "UTF-8");
			nextTokenStart = nextTokenEnd+1;		// skip the '&' character
		} finally {
			parameters.put(parameterName, parameterValue);
		}

		return parameters;
	}

	
	public enum InstantVASSMSWebHandlers implements INativeHTTPServerHandler {
				
		addToMOQueue("/AddToMOQueue") {
			@Override
			public void handle(HttpExchange he) throws IOException {
				String queryString = he.getRequestURI().getRawQuery();
				byte[] response = AddToMOQueue.process(retrieveGetParameters(queryString), queryString);
				he.sendResponseHeaders(200, response.length);
				he.getResponseBody().write(response);
		        he.close();
			}
		}
		
		;
		
		private String contextPath;
		
		private InstantVASSMSWebHandlers(String contextPath) {
			this.contextPath = contextPath;
		}
		
		public String getContextPath() {
			return contextPath;
		}
		
//		private static WeakHashMap<Thread, byte[]> inputBuffers = new WeakHashMap<Thread, byte[]>(NUMBER_OF_THREADS);
//		
//		public static synchronized byte[] getInputBuffer() {
//			byte[] inputBuffer = inputBuffers.get(Thread.currentThread());
//			if (inputBuffer == null) {
//				inputBuffer = new byte[INPUT_BUFFER_SIZE];
//				inputBuffers.put(Thread.currentThread(), inputBuffer);
//			}
//			return inputBuffer;
//		}
//		
//		public static int readNextChunk(InputStream is, byte[] inputBuffer, int currentLength) throws Exception {
//			int available = is.available();
//			if ((available == 0) && (READ_TIMEOUT > 0)) {
//				Thread.sleep(READ_TIMEOUT);
//			}
//			if ((available + currentLength) > INPUT_BUFFER_SIZE) {
//				return -2;
//			}
//			is.read(inputBuffer, currentLength, available);
//			return 0;
//		}
		
	}
		
}
